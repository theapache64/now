package com.github.theapache64.now.perf

import android.os.SystemClock
import android.util.Log
import java.net.URLDecoder
import java.util.concurrent.ConcurrentHashMap
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PerformanceTracer @Inject constructor() {

    val pagePerfTracer = PagePerfTracer
    val apiTracer = ApiTracer
    val apiPerfDataCollector = ApiPerfDataCollector

    fun dump() {
        Log.d(
            "PerfMetrics",
            "Dump:\nAPI tracer:\n${apiTracer.dump()}" +
                    "\nPagePerf tracer:\n${pagePerfTracer.dump()}"
        )
    }

    fun reset() {
        pagePerfTracer.resetMarkers()
        apiTracer.resetMarkers()
    }

    sealed class Tracer(val type: String) {

        companion object {
            const val MARKER_START_KEY = "_START"
            const val MARKER_END_KEY = "_END"
        }

        private val markerHashMap: ConcurrentHashMap<String, Long> = ConcurrentHashMap()
        private val requestIdHashMap: ConcurrentHashMap<String, String> = ConcurrentHashMap()
        private val traceIdHashMap: ConcurrentHashMap<String, String> = ConcurrentHashMap()
        fun startMarker(markerTag: String) {
            Log.d("PerfMetrics", "$type startMarker: $markerTag")
            markerHashMap[markerTag.plus(MARKER_START_KEY)] = SystemClock.uptimeMillis()
        }

        fun endMarker(markerTag: String) {
            Log.d("PerfMetrics", "$type endMarker: $markerTag")
            markerHashMap[markerTag.plus(MARKER_END_KEY)] = SystemClock.uptimeMillis()
        }

        fun isStarted(markerTag: String): Boolean = getStartTime(markerTag) != -1L
        fun isEnded(markerTag: String): Boolean = getEndTime(markerTag) != -1L

        fun getStartTime(markerTag: String): Long {
            return markerHashMap[markerTag.plus(MARKER_START_KEY)] ?: -1L
        }

        private fun getEndTime(markerTag: String): Long {
            return markerHashMap[markerTag.plus(MARKER_END_KEY)] ?: -1L
        }

        fun getMeasureTime(markerTag: String): Long {
            var timeDiff = -1L
            val startTimestamp: Long = markerHashMap[markerTag.plus(MARKER_START_KEY)] ?: -1L
            val endTimeStamp = markerHashMap[markerTag.plus(MARKER_END_KEY)] ?: -1L
            if (startTimestamp != -1L && endTimeStamp != -1L && startTimestamp <= endTimeStamp) {
                timeDiff = endTimeStamp - startTimestamp
            }
            return timeDiff
        }

        fun resetMarkers() {
            markerHashMap.clear()
            requestIdHashMap.clear()
        }

        fun clearMarker(markerTag: String) {
            Log.d("PerfMetrics", "clearMarker")
            markerHashMap.remove(markerTag.plus(MARKER_START_KEY))
            markerHashMap.remove(markerTag.plus(MARKER_END_KEY))
        }

        fun dump(): String {
            var ret = ""
            markerHashMap.toSortedMap().forEach {
                ret += "${it.key} - ${it.value}\n"
            }
            return ret
        }

        fun addTraceId(pageUrl: String, traceId: String) {
            traceIdHashMap[pageUrl] = traceId
        }

        fun getTraceId(pageUrl: String): String {
            return traceIdHashMap[pageUrl] ?: ""
        }

        fun addRequestId(pageUrl: String, requestId: String) {
            if (isStarted(pageUrl)) {
                requestIdHashMap[pageUrl] = requestId
            }
        }

        fun getRequestId(pageUrl: String): String {
            return requestIdHashMap[pageUrl] ?: ""
        }

        fun popRequestId(pageUrl: String) {
            requestIdHashMap.remove(pageUrl)
        }
    }

    object ApiTracer : Tracer("ApiTracer")
    object PagePerfTracer : Tracer("PagePerfTracer") {
        const val APP_STARTUP_MARKER = "APP_STARTUP_MARKER"

        fun protoMakerStart(marker: String) {
            startMarker(marker.plus("PROTO_MARKER"))
        }

        fun protoMarkerEnd(marker: String) {
            endMarker(marker.plus("PROTO_MARKER"))
        }

        fun getProtoMeasureTime(marker: String): Long {
            return getMeasureTime(marker.plus("PROTO_MARKER"))
        }

        fun clearProtoMarker(marker: String) {
            clearMarker(marker.plus("PROTO_MARKER"))
        }
    }
}

fun String.toPerfKey(): String {
    val cachedKey = perfKeyCache[this]
    return if (cachedKey != null) {
        cachedKey
    } else {
        val key = this.simpleUrlKey()
        perfKeyCache[this] = key
        key
    }
}

private val perfKeyCache = ConcurrentHashMap<String, String>()

/**
 * This function is used to generate a simple key from the input url string.
 * The key is generated by
 * 1. removing the query parameters from the url
 * 2. sorting the query parameters
 * 3. decoding the url
 */
internal fun String.simpleUrlKey(): String {
    try {
        if (this.isEmpty()) {
            return this
        }
        val url = this.split("?")
        val hostAndPath = url[0]
        val query = if (url.size > 1) url[1] else null
        val (_, path) = hostAndPath.parseHostPath()
        val queryParams = query?.split("&")?.map { param ->
            val keyValue = param.split("=", limit = 2)
            keyValue.first() to (if (keyValue.size > 1) keyValue[1] else "")
        }?.toMutableList()

        // remove the item from the queryParams list if the key matches any of the value in excludeQueries
        queryParams?.let {
            val iterator = it.iterator()
            while (iterator.hasNext()) {
                val q = iterator.next()
                if (q.first in excludeQueries) {
                    iterator.remove()
                }
            }
        }

        queryParams?.sortBy { it.first }

        val sortedQueryParams = queryParams?.joinToString("&") { "${it.first}=${it.second}" }

        return URLDecoder.decode(
            "${path ?: ""}${if (sortedQueryParams != null) "?${sortedQueryParams}" else ""}",
            "UTF-8"
        )
    } catch (e: Exception) {
        e.printStackTrace()
        return this
    }
}

internal fun String.parseHostPath(): Pair<String?, String?> {
    // Implement the function to parse the host and the path from the input string
    // Input only contains host and path
    // example: "https://www.hotstar.com/in/tv-shows"
    // Output: Pair("www.hotstar.com", "/in/tv-shows")

    val startIndex = this.indexOf("//").let {
        if (it != -1) {
            it + 2
        } else {
            -1
        }
    }
    val pathStartIndex = this.indexOf('/', startIndex)
    val pathEndIndex = this.indexOf('?', pathStartIndex)

    val host = if (startIndex != -1) {
        if (pathStartIndex != -1) {
            this.substring(startIndex, pathStartIndex)
        } else {
            this.substring(startIndex, this.length)
        }
    } else {
        null
    }

    val path = if (pathStartIndex != -1) {
        if (pathEndIndex != -1) {
            this.substring(pathStartIndex, pathEndIndex)
        } else {
            this.substring(pathStartIndex, this.length)
        }
    } else {
        null
    }

    return Pair(host, path)
}

// TODO: this should come from LD.
private val excludeQueries = listOf("client_capabilities", "drm_parameters", "request_features", "lang")
